import os

import sys
sys.path.append("/home/discordbot")
from nevow.appserver import NevowSite
from nevow.static import File, Data
from nevow import inevow
from nevow.inevow import IResource
from twisted.python.filepath import FilePath
from twisted.internet import reactor
import subprocess
from io import BytesIO
import json
from zope.interface import implementer
from twisted.python.log import startLogging
from .verify import Verify
import mimetypes
from collections import defaultdict
from attr import attrs, attrib, asdict
import subprocess

ADMINISTRATOR = 0x0000000000000008

rsrc = FilePath(__file__).sibling("xfer")

NEWLINE="\n"

database = FilePath(os.environ["DATABASE"])


@attrs(auto_attribs=True, init=False)
class Reference(object):
    channel_id: str
    id: str
    def __init__(self, *, channel_id=None, id=None, **kw):
        self.channel_id = channel_id
        self.id = id
    

@attrs(auto_attribs=True)
class Issue(object):
    name: str
    guild_id: str
    messages: list = attrib(factory=list)
    references: list = attrib(factory=list)
    complete: bool = False
    response: str = None
    p: object = None

    def reference(self, r):
        r = next(iter(r.values()))
        return f"https://discord.com/channels/{self.guild_id}/{r['channel_id']}/{r['id']}"

    def _submit(self):
        p = self.p
        if p.poll() is None:
            reactor.callLater(1, self._submit)
        else:
            self.response = p.stdout.read().decode('utf-8')

    def submit(self):
        if not self.complete:
            return string("You must mark the issue complete first and ensure it looks correct")
        if self.p:
            return string("You already submitted this issue")
        c = self.content
        
        p = self.p = subprocess.Popen(['gh', 'issue', 'create', '-R', GuildRecords[self.guild_id].github_repository, '-F', '-', '-t', self.name], stdin=subprocess.PIPE, stdout=subprocess.PIPE)
        p.stdin.write(c.encode('utf-8'))
        p.stdin.close()
        if p.poll() is None:
            reactor.callLater(1, self._submit)
            return string("use `/issue status` to get URL of new issue")
        return string(p.stdout.read().decode('utf-8'))

    def serialize(self):
        return f'''```{self.content}```'''
    @property
    def content(self):
        if not self.messages:
            return "Must include at least one message to describe the issue"
        self.complete = True
        return f'''
## Autogenerated Issue
Name: {self.name}
Short Description: {self.messages[0]}
Context: {str.join(NEWLINE, self.messages[1:])}
References: {str.join(NEWLINE, (self.reference(i) for i in self.references))}

'''

@attrs(auto_attribs=True, slots=True)
class GuildRecord(object):
    guild_id: str
    authorized_role: str = None
    authorized_role_name: str = "No role set"
    issues_in_progress: dict = attrib(factory=dict)
    timeouts: dict = attrib(factory=lambda: defaultdict(lambda: None)) 
    github_repository: str = None


@lambda x: x(lambda k: GuildRecord(k))
class GuildRecords(defaultdict):
    def __missing__(self, key):
        self[key] = value = self.default_factory(key)
        return value
    
    
if database.exists():
    GuildRecords.update(({k: GuildRecord(**v) for k,v in json.loads(database.getContent().decode('utf-8')).items()}))

def string(msg):
    return dict(
        type=4,
        data=dict(
            tts=False,
            content=msg))
                

@implementer(IResource)
class DiscordBot(object):
    public_key = FilePath(os.environ['HOME']).child("pubkey").getContent().decode('utf-8')
    verifier = Verify(public_key)
    def renderHTTP(self, ctx):
        ireq = inevow.IRequest(ctx)
        r = self._renderHTTP(ctx)
        print(r)
        if isinstance(r, (dict, list, int)):
            return json.dumps(r)
        return r
    def _renderHTTP(self, ctx: "PageContext"):
        ireq = inevow.IRequest(ctx)
        b = ireq.content.read()
        a = self.verifier.verify(b, ireq.received_headers.get("X-Signature-Ed25519"), ireq.received_headers.get("X-Signature-Timestamp"))
        if not a:
            print("Sending 401")
            ireq.setResponseCode(401, b'invalid request signature')
            ireq.finish()
            return ""
        cmdstr = b.decode('utf-8')
        cmd = json.loads(cmdstr)
        ireq.setHeader("Content-Type", "application/json")
        
        match cmd:
            case {'type': 1}:
                return json.dumps({
                    "type": 1
                })
            case {'type': 2, 'member': {'permissions': permissions, "roles": roles, "user": {"id": user_id}}, "guild_id": guild_id}:
                permissions = int(permissions)
                if not (permissions & ADMINISTRATOR):
                    if not roles:
                        return string("Permission denied")
                    for role in roles:
                        if role == GuildRecords[guild_id].authorized_role:
                            break
                    else:
                        return string("Permission denied")    


            case _:
                return string("Unknown command")
        match cmd:
            case {'type': 2, 'data':
                  {'name': 'issue', 'options':
                   [{"name": "repository", "options": [{"name": "set", "options": [{"value": content}]}]}]}}:
                if permissions & ADMINISTRATOR:
                    GuildRecords[guild_id].github_repository = content
                    return string(f"setting repository to `{content}`")
                return string(f"Permission denied")
            

            case {'type': 2, 'data':
                  {'name': 'issue', 'options':
                   [{"name": "repository", "options": [{"name": "get"}]}]}}:
                return string(f"repository: {GuildRecords[guild_id].github_repository}")
        
            case {'type': 2, 'data':
                  {'name': 'issue', 'options':
                   [{"name": "role", "options": [{"name": "get"}]}]}}:
                return string(f"role: {GuildRecords[guild_id].authorized_role_name}")
            case {'type': 2, 'data':
                  {'name': 'issue', 'options':
                   [{"name": "role", "options": [{"name": "set"}]}],
                   'resolved': {"roles": roles}}}:
                if permissions & ADMINISTRATOR:
                    if len(roles) > 1:
                        return string("setrole requires mentioning **1** @role")
                    role = next(iter(roles.values()))
                    GuildRecords[guild_id].authorized_role = role['id']
                    GuildRecords[guild_id].authorized_role_name = role['name']
                    return string(f"setting authorized role to `@{role['name']}`")
                return string(f"Permission denied")
            
            case {'type': 2, 'data':
                  {'name': 'issue', 'options':
                   [{"name": "role", "options": [{"name": "set"}]}]}}:
                return dict(
                    type=4,
                    data=dict(
                        tts=False,
                        content="setrole requires mentioning a @role"
                    )
                )
                    
            case {'type': 2, 'data': {'name': 'issue', 'options': [
                {'name': 'start', 'options': [{'value': issue_name}]}]}}:
                issue = GuildRecords[guild_id].issues_in_progress[user_id] = Issue(issue_name, guild_id)
                return string("Creating new issue")
            case {'type': 2, 'data': {'name': 'issue', 'options': [
                {'name': 'add', 'options': [{'value': content}]}]}}:
                issue: Issue = GuildRecords[guild_id].issues_in_progress.get(user_id)
                if not issue:
                    return string("No issue started, maybe you meant `/startissue`?")
                issue.messages.append(content)
                return string("Adding text to current issue")
            case {'type': 2, 'data': {'name': 'AddToIssue', 'resolved': {'messages': content}}, 'member': {"user": {"id": user_id}}}:
                issue: Issue = GuildRecords[guild_id].issues_in_progress.get(user_id)
                if not issue:
                    return string("No issue started, maybe you meant `/startissue`?")
                issue.references.append(Reference(**content))
                return string("Adding message to current issue")

            case {'type': 2, 'data': {'name': 'issue', 'options': [
                {'name': 'complete'}]}}:
                issue: Issue = GuildRecords[guild_id].issues_in_progress.get(user_id)
                if not issue:
                    return string("No issue started, maybe you meant `/startissue`?")
                return string(issue.serialize())

            case {'type': 2, 'data': {'name': 'issue', 'options': [
                {'name': 'status'}]}}:
                issue: Issue = GuildRecords[guild_id].issues_in_progress.get(user_id)
                if not issue:
                    return string("No issue started, maybe you meant `/startissue`?")
                if issue.response:
                    return string(f"Issue submitted: {issue.response}")
                return string(f"Issue {issue.name} pending with {len(issue.messages)} parts and {len(issue.references)} referenced messages")
            case {'type': 2, 'data': {'name': 'issue', 'options': [
                {'name': 'submit'}]}}:
                if GuildRecords[guild_id].timeouts[user_id] and not (permissions & ADMINISTRATOR):
                    return string("Cannot create more than one issue per 10 minutes")
                issue: Issue = GuildRecords[guild_id].issues_in_progress.get(user_id)
                if issue.complete:
                    GuildRecords[guild_id].timeouts[user_id] = reactor.callLater(600, lambda: GuildRecords[guild_id].timeouts.pop(user_id))
                    return issue.submit()
            case {'type': 2, 'data': {'name': 'issue'}}:
                return string("Subcommand not recognized")
            case {'type': 2}:
                return json.dumps({
                    "type": 4,
                    "data": {
                        "tts": False,
                        "content": f"Unrecognized command: {cmd.get('data', {}).get('name')}"
                    }
                })
                    
    def locateChild(self, ctx, segments):
        return self, []


def SaveDatabase():
    database.setContent(json.dumps(({k:asdict(v, filter=lambda x, y: x.name not in ('timeouts', 'issues_in_progress', 'timeouts')) for k,v in GuildRecords.items()}), indent=4).encode('utf-8'))


resource = DiscordBot()
factory = NevowSite(resource)
if __name__ == '__main__':
    from twisted.internet import reactor
    startLogging(sys.stdout)
    reactor.listenTCP(8080, factory)
    reactor.stopCallbacks.append(SaveDatabase)
    reactor.run()

else:
    from ReverseProxy.reactor import reactor
    reactor.stopCallbacks.append(SaveDatabase)
