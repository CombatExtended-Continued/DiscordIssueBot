import os

import sys
sys.path.append("/home/discordbot")
from nevow.appserver import NevowSite
from nevow.static import File, Data
from nevow import inevow
from nevow.inevow import IResource
from twisted.python.filepath import FilePath
from twisted.internet import reactor
import subprocess
from io import BytesIO
import json
from zope.interface import implementer
from twisted.python.log import startLogging
from .verify import Verify
import mimetypes
from collections import defaultdict
from attr import attrs, attrib, asdict
import subprocess

ADMINISTRATOR = 0x0000000000000008

rsrc = FilePath(__file__).sibling("xfer")

NEWLINE="\n"

database = FilePath(os.environ["DATABASE"])

HELP = """```
All issue bot commands start with `/issue `
`/issue help` displays this help message
`/issue start <name>` begins a new issue (discarding *your* current issue, if any)
`/issue summary <summary>` sets the short description.  This must be done before the preview can be generated
`/issue add <message>` adds <message> to the `context` section of the issue
`/issue remove message [idx]` removes a message from the context section (0 indexed, defaults to last message, negative numbers count from the end)
`/issue remove reference [idx]` removes a reference from the references section (0 indexed, defaults to the last message, negative numbers count from the end)
`/issue preview` generates the issue that will be posted to github.  Must be run before `/issue submit`
`/issue status` summarizes the current status of the issue (number of included messages or references).  For submitted issues, retrieves the URL
`/issue submit` submits an issue to github

Messages can be added to the reference section via the message-right-click -> apps menu.

`/issue role get` gives the name of the role that is allowed to use bot commands
`/issue role set` sets the role (@mention the role itself).  Requires administrator access to use
`/issue repository get` gives the name of the github org/repo to which issues will be posted.
`/issue repository set` sets the name of the github org/repo.  Requires administrator access
```
"""


@attrs(auto_attribs=True, init=False)
class Reference(object):
    channel_id: str
    id: str
    def __init__(self, *, channel_id, id, **kw):
        self.channel_id = channel_id
        self.id = id
    

@attrs(auto_attribs=True)
class Issue(object):
    name: str
    guild_id: str
    username: str
    summary: str = None
    messages: list = attrib(factory=list)
    references: list = attrib(factory=list)
    complete: bool = False
    response: str = None
    p: object = None

    def reference(self, r):
        return f"https://discord.com/channels/{self.guild_id}/{r.channel_id}/{r.id}"

    def _submit(self):
        p = self.p
        if p.poll() is None:
            reactor.callLater(1, self._submit)
        else:
            self.response = p.stdout.read().decode('utf-8')

    def submit(self):
        if not self.complete:
            return string("You must mark the issue complete first and ensure it looks correct")
        if self.p:
            return string("You already submitted this issue")
        c = self.content
        
        p = self.p = subprocess.Popen(['gh', 'issue', 'create', '-R', GuildRecords[self.guild_id].github_repository, '-F', '-', '-t', self.name], stdin=subprocess.PIPE, stdout=subprocess.PIPE)
        p.stdin.write(c.encode('utf-8'))
        p.stdin.close()
        if p.poll() is None:
            reactor.callLater(1, self._submit)
            return string("use `/issue status` to get URL of new issue")
        return string(p.stdout.read().decode('utf-8'))

    def serialize(self):
        return f'''```{self.content}```'''
    @property
    def content(self):
        if not self.summary:
            return "You must set the summary"
        self.complete = True
        return f'''
## Autogenerated Issue
Name: {self.name}
Submitted By: {self.username}
Short Description: {self.summary}
Context: {str.join(NEWLINE, self.messages)}
References: {str.join(NEWLINE, (self.reference(i) for i in self.references))}

'''

@attrs(auto_attribs=True, slots=True)
class GuildRecord(object):
    guild_id: str
    authorized_role: str = None
    authorized_role_name: str = "No role set"
    issues_in_progress: dict = attrib(factory=dict)
    timeouts: dict = attrib(factory=lambda: defaultdict(lambda: None)) 
    github_repository: str = None


@lambda x: x(lambda k: GuildRecord(k))
class GuildRecords(defaultdict):
    def __missing__(self, key):
        self[key] = value = self.default_factory(key)
        return value
    
    
if database.exists():
    GuildRecords.update(({k: GuildRecord(**v) for k,v in json.loads(database.getContent().decode('utf-8')).items()}))

def string(msg):
    return dict(
        type=4,
        data=dict(
            tts=False,
            content=msg))
                

@implementer(IResource)
class DiscordBot(object):
    public_key = FilePath(os.environ['HOME']).child("pubkey").getContent().decode('utf-8')
    verifier = Verify(public_key)
    def renderHTTP(self, ctx):
        ireq = inevow.IRequest(ctx)
        r = self._renderHTTP(ctx)
        print(r)
        if isinstance(r, (dict, list, int)):
            return json.dumps(r)
        return r
    def _renderHTTP(self, ctx: "PageContext"):
        ireq = inevow.IRequest(ctx)
        b = ireq.content.read()
        a = self.verifier.verify(b, ireq.received_headers.get("X-Signature-Ed25519"), ireq.received_headers.get("X-Signature-Timestamp"))
        if not a:
            print("Sending 401")
            ireq.setResponseCode(401, b'invalid request signature')
            ireq.finish()
            return ""
        cmdstr = b.decode('utf-8')
        cmd = json.loads(cmdstr)
        ireq.setHeader("Content-Type", "application/json")
        
        match cmd:
            case {'type': 1}:
                return json.dumps({
                    "type": 1
                })
            case {'type': 2, 'data': {'name': 'issue', 'options': [{"name": "help"}]}}:
                return string(HELP)
            case {'type': 2, 'member': {'permissions': permissions, "roles": roles, "user": {"id": user_id, "username": username}}, "guild_id": guild_id}:
                permissions = int(permissions)
                if not (permissions & ADMINISTRATOR):
                    if not roles:
                        return string("Permission denied")
                    for role in roles:
                        if role == GuildRecords[guild_id].authorized_role:
                            break
                    else:
                        return string("Permission denied")    


            case _:
                return string("Unknown command")
        print(cmd)
        match cmd:
            case {'type': 2, 'data':
                  {'name': 'issue', 'options':
                   [{"name": "remove", "options": [{"name": "message", "options": options}]}]}}:
                if options:
                    index = options[0]["value"]
                else:
                    index = -1
                issue: Issue = GuildRecords[guild_id].issues_in_progress.get(user_id)
                if not issue:
                    return string("No issue started, maybe you meant `/issue start`?")
                if issue.response:
                    return string("Cannot edit already submitted issue, ise `/issue status` to get the issue number, or `/issue start` to start a new issue")
                
                try:
                    return string(f"removing {issue.messages.pop(index)}")
                except IndexError:
                    return string("List index out of range")
                
            case {'type': 2, 'data':
                  {'name': 'issue', 'options':
                   [{"name": "remove", "options": [{"name": "reference", "options": options}]}]}}:
                if options:
                    index = options[0]["value"]
                else:
                    index = -1
                issue: Issue = GuildRecords[guild_id].issues_in_progress.get(user_id)
                if not issue:
                    return string("No issue started, maybe you meant `/issue start`?")
                if issue.response:
                    return string("Cannot edit already submitted issue, ise `/issue status` to get the issue number, or `/issue start` to start a new issue")
                try:
                    msg = issue.references.pop(index)
                    return string(f"removing reference to {msg.id}")
                except IndexError:
                    return string("List index out of range")
                
            
            case {'type': 2, 'data':
                  {'name': 'issue', 'options':
                   [{"name": "repository", "options": [{"name": "set", "options": [{"value": content}]}]}]}}:
                if permissions & ADMINISTRATOR:
                    GuildRecords[guild_id].github_repository = content
                    return string(f"setting repository to `{content}`")
                return string(f"Permission denied")
            

            case {'type': 2, 'data':
                  {'name': 'issue', 'options':
                   [{"name": "repository", "options": [{"name": "get"}]}]}}:
                return string(f"repository: {GuildRecords[guild_id].github_repository}")
        
            case {'type': 2, 'data':
                  {'name': 'issue', 'options':
                   [{"name": "role", "options": [{"name": "get"}]}]}}:
                return string(f"role: {GuildRecords[guild_id].authorized_role_name}")
            case {'type': 2, 'data':
                  {'name': 'issue', 'options':
                   [{"name": "role", "options": [{"name": "set"}]}],
                   'resolved': {"roles": roles}}}:
                if permissions & ADMINISTRATOR:
                    if len(roles) > 1:
                        return string("setrole requires mentioning **1** @role")
                    role = next(iter(roles.values()))
                    GuildRecords[guild_id].authorized_role = role['id']
                    GuildRecords[guild_id].authorized_role_name = role['name']
                    return string(f"setting authorized role to `@{role['name']}`")
                return string(f"Permission denied")
            
            case {'type': 2, 'data':
                  {'name': 'issue', 'options':
                   [{"name": "role", "options": [{"name": "set"}]}]}}:
                return dict(
                    type=4,
                    data=dict(
                        tts=False,
                        content="setrole requires mentioning a @role"
                    )
                )
                    
            case {'type': 2, 'data': {'name': 'issue', 'options': [
                {'name': 'start', 'options': [{'value': issue_name}]}]}}:
                issue = GuildRecords[guild_id].issues_in_progress[user_id] = Issue(issue_name, guild_id, username)
                return string("Starting new issue.  You can now add text to the issue via `/issue add`, and set a summary via `/issue summary`.  You can also reference existing messages via the message right click menu.")
            case {'type': 2, 'data': {'name': 'issue', 'options': [
                {'name': 'add', 'options': [{'value': content}]}]}}:
                issue: Issue = GuildRecords[guild_id].issues_in_progress.get(user_id)
                if not issue:
                    return string("No issue started, maybe you meant `/issue start`?")
                if issue.response:
                    return string("Cannot edit already submitted issue, ise `/issue status` to get the issue number, or `/issue start` to start a new issue")
                issue.messages.append(content)
                return string("Adding text to current issue")
            case {'type': 2, 'data': {'name': 'issue', 'options': [
                {'name': 'summary', 'options': [{'value': content}]}]}}:
                issue: Issue = GuildRecords[guild_id].issues_in_progress.get(user_id)
                if not issue:
                    return string("No issue started, maybe you meant `/issue start`?")
                if issue.response:
                    return string("Cannot edit already submitted issue, ise `/issue status` to get the issue number, or `/issue start` to start a new issue")
                issue.summary = content
                return string("Setting issue summary")
            case {'type': 2, 'data': {'name': 'AddToIssue', 'resolved': {'messages': content}}, 'member': {"user": {"id": user_id}}}:
                issue: Issue = GuildRecords[guild_id].issues_in_progress.get(user_id)
                if not issue:
                    return string("No issue started, maybe you meant `/issue start`?")
                if issue.response:
                    return string("Cannot edit already submitted issue, ise `/issue status` to get the issue number, or `/issue start` to start a new issue")
                issue.references.append(Reference(**next(iter(content.values()))))
                return string("Adding message to current issue")
            case {'type': 2, 'data': {'name': 'issue', 'options': [
                {'name': 'preview'}]}}:
                issue: Issue = GuildRecords[guild_id].issues_in_progress.get(user_id)
                if not issue:
                    return string("No issue started, maybe you meant `/issue start`?")
                return string(issue.serialize())

            case {'type': 2, 'data': {'name': 'issue', 'options': [
                {'name': 'status'}]}}:
                issue: Issue = GuildRecords[guild_id].issues_in_progress.get(user_id)
                if not issue:
                    return string("No issue started, maybe you meant `/issue start`?")
                if issue.response:
                    GuildRecords[guild_id].issues_in_progress.pop(user_id)
                    return string(f"Issue submitted: {issue.response}")
                return string(f"Issue {issue.name} pending with {len(issue.messages)} parts and {len(issue.references)} referenced messages")
            case {'type': 2, 'data': {'name': 'issue', 'options': [
                {'name': 'submit'}]}}:
                if GuildRecords[guild_id].timeouts[user_id] and not (permissions & ADMINISTRATOR):
                    return string("Cannot create more than one issue per 10 minutes")
                issue: Issue = GuildRecords[guild_id].issues_in_progress.get(user_id)
                if issue is None:
                    return string("You do not have an open issue, perhaps you meant `/issue start`?")
                if issue.response:
                    return string("Cannot submit already submitted issue, ise `/issue status` to get the issue number, or `/issue start` to start a new issue")
                if issue.complete:
                    GuildRecords[guild_id].timeouts[user_id] = reactor.callLater(600, lambda: GuildRecords[guild_id].timeouts.pop(user_id))
                    return issue.submit()
                return string("You must run `/issue complete` before you can submit the issue")
            case {'type': 2, 'data': {'name': 'issue'}}:
                print(cmd['data'])
                return string("Subcommand not recognized")
            case {'type': 2}:
                return json.dumps({
                    "type": 4,
                    "data": {
                        "tts": False,
                        "content": f"Unrecognized command: {cmd.get('data', {}).get('name')}"
                    }
                })
                    
    def locateChild(self, ctx, segments):
        return self, []


def SaveDatabase():
    database.setContent(json.dumps(({k:asdict(v, filter=lambda x, y: x.name not in ('timeouts', 'issues_in_progress', 'timeouts')) for k,v in GuildRecords.items()}), indent=4).encode('utf-8'))


resource = DiscordBot()
factory = NevowSite(resource)
if __name__ == '__main__':
    from twisted.internet import reactor
    startLogging(sys.stdout)
    reactor.listenTCP(8080, factory)
    reactor.stopCallbacks.append(SaveDatabase)
    reactor.run()

else:
    from ReverseProxy.reactor import reactor
    reactor.stopCallbacks.append(SaveDatabase)
